---
title: "iperform"
output: rmarkdown::html_vignette
description:
  "Comment utiliser les fonctions du pacakge iperform qui donnent les performances de l'evolution d'une série temporelle à une date donnée."
vignette: >
  %\VignetteIndexEntry{iperform}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Introduction

En finance, en comptabilité ou en marketing operationnel, les ateurs suivent au quotidien l'évolution de leur activité en comparant à chaque fois les résultats d'une date (ou d'une periode) à une date (ou une période) antérieure ou par rapport aux résultats du marché et des concurrents directs. On parle là des concepts de performance :

* year to date : qui conrespond au résultat cumulé commençant le premier jour de l’année civil ou de l'exercice en cours jusqu’à la date actuelle,

* month to date : qui conrespond au résultat cumulé commençant le premier jour du mois jusqu’à la date actuelle au cours du même mois,

* week to date : qui conrespond au résultat cumulé commençant le permier jour de la semaine jusqu’à la date actuelle au cours de la même semaine.


On peut egalement utiliser les concepts *day to date* (pour la durée écoulée au cours d'une journée pour ceux qui suivent l’activité par heure) ou *quater to date* (pour la durée écoulée sur un trimestre) ou encore *full month*, *full year*, etc pour designer la totalité de la periode indiquée.

C'est ainsi que cette vignette decrit l'utilisation des differentes fonctions offerte par le package *iperfom* telle que `d_day()`, `wtd()`, `mtd()`, et `ytd()` qui renvois ces valeur pour une série temporelle à une date précise ou une intervalle de temps donné.

Avec la revolution des solutions Big Data sur la visualisation des données, plusieurs tableaux de bord utilisent ces concepts en combinaison avec les variations par rapport aux dates ou periodes antérieures pour enrichir l'histoire lors de la présentation des données, des résultats ou de la performance de l’activité. C'est ce qui donne toute la motivation de rassembler dans un seul paquet, toutes fonctions qui repondent à ce besoin, d'où le package *iperform*.

Le package *iperform* , couplé avec le package R *lubridate* offre en cette première version les principales fonctions que voici regrouper en cinq (5) catégories :

### les performances

* `d_day()` qui renvoie la valeur d'une série à une date donnée en argument.

* `wtd()` qui renvoie la somme des valeurs de la série depuis le début de la semaine correspondante à la date renseignée en argurment.

* `mtd()` qui renvoie la somme des valeurs de la série depuis le début du mois correspondant à la date renseignée en argurment.

* `ytd()` qui renvoie la somme des valeurs de la série depuis le début de l’année correspondante à la date renseignée en argurment.

* `full_m()` qui renvoie la somme des valeurs de la série depuis sur tout le mois correspondant à la date renseignée en argurment.


### les aperçus

* `overview()` qui renvoie à l'image de la fonction `summary()`, un résumé des performances couplé avec des comparaisons par rapport aux périodes antérieures de la série.



### les previsions

* `forecast_m()` qui renvoie l'estimation des valeurs de la série en des dates futures en utilisateur un modèle spécifique de prédiction.


### les transformations

* `m_mean()`qui renvoie des nouveaux jeu des données créés après transformation de la série intiales. On cite , 

* `rva()` qui renvoie les effets expliquant la vartiation d'une série par rapport aux autres séries sur la même période.


### les nettoyages

* `v_atypique()` qui modifient les valeurs de la série en s'attanquant aux valeurs atypiques telles que les valeurs manquantes, les valeurs etrêmes, etc.


Dans cette vignette, on présente les mecanismes des calculs derrière ces fonctions.


## Exemples

Pour commencer, nous allons charger quelques packages nécessaires

```{r setup, message=FALSE}
library(lubridate)
library(iperform)

```


Nous allons illustré le fonctionnement de ces fonctions à l'aide d'un jeu de données contenant les indicateurs de l’activité du service voix au pres d'un operateur de téléphonie mobile.

```{r}
data(voix_tel_mob)

```

Ce jeu des données contient 4 variables :

* `date`, variable de type date qui part du 1er janvier 2021 au 30 septembre 2023,

* `parc`, variable de type numeric qui renseigne le nombre des clients qui ont effectué au moin un appel sortant,

* `usage`, variable de type numeric qui renseigne le nombre des minutes consommées par l'ensemble des clients lors des appels, et

* `revenu`, variable de type numeric qui renseigne le chiffre d'affaire ou revenu généré par les usages des clients à un tarif quelconque.


Pour connaitre le `revenu` que l'ensemble des clients ont généré en date du *11 août 2023*, on utilise la fonction `d_day()` comme suit :

```{r}
d_day(data = voix_tel_mob,
      date = "2023-08-11",
      d = 0,
      x = "revenu",
      unite = 1,
      decimal = 0)

```


### Les arguments

* `data` le jeu des données qui contient l'ensemble des données à exploiter,

* `date` un character qui renseine la date à laquelle on cherche l'information,

* `d` un entier qui determine le decalage des jours à prendre, la valeur par défaut vaut `0`. si `d=1`, on prendra la date du *10 août 2023*,

* `unite` un numeric qui renseigne l'echel des valeurs qu'on souhaite avoir.  sa valeur par defaut vaut `1`. Si `unite=1000`, la fonction va renvoyer une valeur diviser par `1000`, et

* `decimal` un entier designant le nombre de chiffre après la virgule qu'on souhaite afficher si le résultat est un decimal. Sa valeur par défaut vaut `0`.



Pour connaître la performance *month-to-date* du revenu réalisée en date du *11 août 2023*, c'est-à-dire la somme des valeurs partant du *01 août 2023* au *11 août 2023* inclus, on utilise la fonction `mtd()` comme suit :

```{r}
mtd(data = voix_tel_mob,
    date = "2023-08-11",
    m = 0,
    x = "revenu",
    unite = 1,
    decimal = 0)

```


ici, seul l'argument `m` est nouveau, les autres ont la même utilité que pour la fonction `d_day()`.

* `m` un entier qui determine le decalage du mois à prendre, la valeur par défaut vaut `0`. si `m=1`, on prendra la date du *11 juillet 2023*.


Pour connaître la performance *year-to-date* du revenu réalisée en date du *11 août 2023*, c'est-à-dire la somme des valeurs partant du *01 janvier 2023* au *11 août 2023* inclus, on utilise la fonction `ytd()` comme suit :

```{r}
ytd(data = voix_tel_mob,
    date = "2023-08-11",
    a = 0,
    x = "revenu",
    unite = 1,
    decimal = 0)

```

idem pour les arguments.

* `a` un entier qui determine le decalage de l’année à prendre, la valeur par défaut vaut `0`. Si `a=1`, on prendra la date du *11 août 2022*.


Cas des fonctions aperçu 

```{r}


```

